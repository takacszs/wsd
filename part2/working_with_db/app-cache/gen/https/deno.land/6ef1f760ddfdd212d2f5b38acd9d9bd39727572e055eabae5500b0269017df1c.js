// express is set like: app.engine('html', require('eta').renderFile)
import EtaErr from "./err.ts";
import compile from "./compile.ts";
import { getConfig } from "./config.ts";
import { getPath, readFile } from "./file-utils.ts";
import { promiseImpl } from "./polyfills.ts";
/* END TYPES */ /**
 * Reads a template, compiles it into a function, caches it if caching isn't disabled, returns the function
 *
 * @param filePath Absolute path to template file
 * @param options Eta configuration overrides
 * @param noCache Optionally, make Eta not cache the template
 */ export function loadFile(filePath, options, noCache) {
    const config = getConfig(options);
    const template = readFile(filePath);
    try {
        const compiledTemplate = compile(template, config);
        if (!noCache) {
            config.templates.define(config.filename, compiledTemplate);
        }
        return compiledTemplate;
    } catch (e) {
        throw EtaErr("Loading file: " + filePath + " failed:\n\n" + e.message);
    }
}
/**
 * Get the template from a string or a file, either compiled on-the-fly or
 * read from cache (if enabled), and cache the template if needed.
 *
 * If `options.cache` is true, this function reads the file from
 * `options.filename` so it must be set prior to calling this function.
 *
 * @param options   compilation options
 * @return Eta template function
 */ function handleCache(options) {
    const filename = options.filename;
    if (options.cache) {
        const func = options.templates.get(filename);
        if (func) {
            return func;
        }
        return loadFile(filename, options);
    }
    // Caching is disabled, so pass noCache = true
    return loadFile(filename, options, true);
}
/**
 * Try calling handleCache with the given options and data and call the
 * callback with the result. If an error occurs, call the callback with
 * the error. Used by renderFile().
 *
 * @param data template data
 * @param options compilation options
 * @param cb callback
 */ function tryHandleCache(data, options, cb) {
    if (cb) {
        try {
            // Note: if there is an error while rendering the template,
            // It will bubble up and be caught here
            const templateFn = handleCache(options);
            templateFn(data, options, cb);
        } catch (err) {
            return cb(err);
        }
    } else {
        // No callback, try returning a promise
        if (typeof promiseImpl === "function") {
            return new promiseImpl(function(resolve, reject) {
                try {
                    const templateFn = handleCache(options);
                    const result = templateFn(data, options);
                    resolve(result);
                } catch (err) {
                    reject(err);
                }
            });
        } else {
            throw EtaErr("Please provide a callback function, this env doesn't support Promises");
        }
    }
}
/**
 * Get the template function.
 *
 * If `options.cache` is `true`, then the template is cached.
 *
 * This returns a template function and the config object with which that template function should be called.
 *
 * @remarks
 *
 * It's important that this returns a config object with `filename` set.
 * Otherwise, the included file would not be able to use relative paths
 *
 * @param path path for the specified file (if relative, specify `views` on `options`)
 * @param options compilation options
 * @return [Eta template function, new config object]
 */ function includeFile(path, options) {
    // the below creates a new options object, using the parent filepath of the old options object and the path
    const newFileOptions = getConfig({
        filename: getPath(path, options)
    }, options);
    // TODO: make sure properties are currectly copied over
    return [
        handleCache(newFileOptions),
        newFileOptions
    ];
}
function renderFile(filename, data, config, cb) {
    /*
  Here we have some function overloading.
  Essentially, the first 2 arguments to renderFile should always be the filename and data
  Express will call renderFile with (filename, data, cb)
  We also want to make (filename, data, options, cb) available
  */ let renderConfig;
    let callback;
    data = data || {};
    // First, assign our callback function to `callback`
    // We can leave it undefined if neither parameter is a function;
    // Callbacks are optional
    if (typeof cb === "function") {
        // The 4th argument is the callback
        callback = cb;
    } else if (typeof config === "function") {
        // The 3rd arg is the callback
        callback = config;
    }
    // If there is a config object passed in explicitly, use it
    if (typeof config === "object") {
        renderConfig = getConfig(config || {});
    } else {
        // Otherwise, get the default config
        renderConfig = getConfig({});
    }
    // Set the filename option on the template
    // This will first try to resolve the file path (see getPath for details)
    renderConfig.filename = getPath(filename, renderConfig);
    return tryHandleCache(data, renderConfig, callback);
}
function renderFileAsync(filename, data, config, cb) {
    return renderFile(filename, typeof config === "function" ? {
        ...data,
        async: true
    } : data, typeof config === "object" ? {
        ...config,
        async: true
    } : config, cb);
}
export { includeFile, renderFile, renderFileAsync };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvZXRhQHYyLjAuMC9maWxlLWhhbmRsZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4cHJlc3MgaXMgc2V0IGxpa2U6IGFwcC5lbmdpbmUoJ2h0bWwnLCByZXF1aXJlKCdldGEnKS5yZW5kZXJGaWxlKVxuXG5pbXBvcnQgRXRhRXJyIGZyb20gXCIuL2Vyci50c1wiO1xuaW1wb3J0IGNvbXBpbGUgZnJvbSBcIi4vY29tcGlsZS50c1wiO1xuaW1wb3J0IHsgZ2V0Q29uZmlnIH0gZnJvbSBcIi4vY29uZmlnLnRzXCI7XG5pbXBvcnQgeyBnZXRQYXRoLCByZWFkRmlsZSB9IGZyb20gXCIuL2ZpbGUtdXRpbHMudHNcIjtcbmltcG9ydCB7IHByb21pc2VJbXBsIH0gZnJvbSBcIi4vcG9seWZpbGxzLnRzXCI7XG5cbi8qIFRZUEVTICovXG5cbmltcG9ydCB0eXBlIHtcbiAgRXRhQ29uZmlnLFxuICBFdGFDb25maWdXaXRoRmlsZW5hbWUsXG4gIFBhcnRpYWxDb25maWcsXG59IGZyb20gXCIuL2NvbmZpZy50c1wiO1xuaW1wb3J0IHR5cGUgeyBUZW1wbGF0ZUZ1bmN0aW9uIH0gZnJvbSBcIi4vY29tcGlsZS50c1wiO1xuXG5leHBvcnQgdHlwZSBDYWxsYmFja0ZuID0gKGVycjogRXJyb3IgfCBudWxsLCBzdHI/OiBzdHJpbmcpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBEYXRhT2JqIHtcbiAgW2tleTogc3RyaW5nXTogYW55OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbn1cblxuaW50ZXJmYWNlIFBhcnRpYWxDb25maWdXaXRoRmlsZW5hbWUgZXh0ZW5kcyBQYXJ0aWFsPEV0YUNvbmZpZz4ge1xuICBmaWxlbmFtZTogc3RyaW5nO1xufVxuXG4vKiBFTkQgVFlQRVMgKi9cblxuLyoqXG4gKiBSZWFkcyBhIHRlbXBsYXRlLCBjb21waWxlcyBpdCBpbnRvIGEgZnVuY3Rpb24sIGNhY2hlcyBpdCBpZiBjYWNoaW5nIGlzbid0IGRpc2FibGVkLCByZXR1cm5zIHRoZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBmaWxlUGF0aCBBYnNvbHV0ZSBwYXRoIHRvIHRlbXBsYXRlIGZpbGVcbiAqIEBwYXJhbSBvcHRpb25zIEV0YSBjb25maWd1cmF0aW9uIG92ZXJyaWRlc1xuICogQHBhcmFtIG5vQ2FjaGUgT3B0aW9uYWxseSwgbWFrZSBFdGEgbm90IGNhY2hlIHRoZSB0ZW1wbGF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRmlsZShcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgb3B0aW9uczogUGFydGlhbENvbmZpZ1dpdGhGaWxlbmFtZSxcbiAgbm9DYWNoZT86IGJvb2xlYW4sXG4pOiBUZW1wbGF0ZUZ1bmN0aW9uIHtcbiAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKG9wdGlvbnMpO1xuICBjb25zdCB0ZW1wbGF0ZSA9IHJlYWRGaWxlKGZpbGVQYXRoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb21waWxlZFRlbXBsYXRlID0gY29tcGlsZSh0ZW1wbGF0ZSwgY29uZmlnKTtcbiAgICBpZiAoIW5vQ2FjaGUpIHtcbiAgICAgIGNvbmZpZy50ZW1wbGF0ZXMuZGVmaW5lKFxuICAgICAgICAoY29uZmlnIGFzIEV0YUNvbmZpZ1dpdGhGaWxlbmFtZSkuZmlsZW5hbWUsXG4gICAgICAgIGNvbXBpbGVkVGVtcGxhdGUsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IEV0YUVycihcbiAgICAgIFwiTG9hZGluZyBmaWxlOiBcIiArIGZpbGVQYXRoICsgXCIgZmFpbGVkOlxcblxcblwiICsgKGUgYXMgRXJyb3IpLm1lc3NhZ2UsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdGVtcGxhdGUgZnJvbSBhIHN0cmluZyBvciBhIGZpbGUsIGVpdGhlciBjb21waWxlZCBvbi10aGUtZmx5IG9yXG4gKiByZWFkIGZyb20gY2FjaGUgKGlmIGVuYWJsZWQpLCBhbmQgY2FjaGUgdGhlIHRlbXBsYXRlIGlmIG5lZWRlZC5cbiAqXG4gKiBJZiBgb3B0aW9ucy5jYWNoZWAgaXMgdHJ1ZSwgdGhpcyBmdW5jdGlvbiByZWFkcyB0aGUgZmlsZSBmcm9tXG4gKiBgb3B0aW9ucy5maWxlbmFtZWAgc28gaXQgbXVzdCBiZSBzZXQgcHJpb3IgdG8gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zICAgY29tcGlsYXRpb24gb3B0aW9uc1xuICogQHJldHVybiBFdGEgdGVtcGxhdGUgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVDYWNoZShvcHRpb25zOiBFdGFDb25maWdXaXRoRmlsZW5hbWUpOiBUZW1wbGF0ZUZ1bmN0aW9uIHtcbiAgY29uc3QgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lO1xuXG4gIGlmIChvcHRpb25zLmNhY2hlKSB7XG4gICAgY29uc3QgZnVuYyA9IG9wdGlvbnMudGVtcGxhdGVzLmdldChmaWxlbmFtZSk7XG4gICAgaWYgKGZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cblxuICAgIHJldHVybiBsb2FkRmlsZShmaWxlbmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBDYWNoaW5nIGlzIGRpc2FibGVkLCBzbyBwYXNzIG5vQ2FjaGUgPSB0cnVlXG4gIHJldHVybiBsb2FkRmlsZShmaWxlbmFtZSwgb3B0aW9ucywgdHJ1ZSk7XG59XG5cbi8qKlxuICogVHJ5IGNhbGxpbmcgaGFuZGxlQ2FjaGUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgZGF0YSBhbmQgY2FsbCB0aGVcbiAqIGNhbGxiYWNrIHdpdGggdGhlIHJlc3VsdC4gSWYgYW4gZXJyb3Igb2NjdXJzLCBjYWxsIHRoZSBjYWxsYmFjayB3aXRoXG4gKiB0aGUgZXJyb3IuIFVzZWQgYnkgcmVuZGVyRmlsZSgpLlxuICpcbiAqIEBwYXJhbSBkYXRhIHRlbXBsYXRlIGRhdGFcbiAqIEBwYXJhbSBvcHRpb25zIGNvbXBpbGF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSBjYiBjYWxsYmFja1xuICovXG5cbmZ1bmN0aW9uIHRyeUhhbmRsZUNhY2hlKFxuICBkYXRhOiBvYmplY3QsXG4gIG9wdGlvbnM6IEV0YUNvbmZpZ1dpdGhGaWxlbmFtZSxcbiAgY2I6IENhbGxiYWNrRm4gfCB1bmRlZmluZWQsXG4pIHtcbiAgaWYgKGNiKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5vdGU6IGlmIHRoZXJlIGlzIGFuIGVycm9yIHdoaWxlIHJlbmRlcmluZyB0aGUgdGVtcGxhdGUsXG4gICAgICAvLyBJdCB3aWxsIGJ1YmJsZSB1cCBhbmQgYmUgY2F1Z2h0IGhlcmVcbiAgICAgIGNvbnN0IHRlbXBsYXRlRm4gPSBoYW5kbGVDYWNoZShvcHRpb25zKTtcbiAgICAgIHRlbXBsYXRlRm4oZGF0YSwgb3B0aW9ucywgY2IpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVyciBhcyBFcnJvcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE5vIGNhbGxiYWNrLCB0cnkgcmV0dXJuaW5nIGEgcHJvbWlzZVxuICAgIGlmICh0eXBlb2YgcHJvbWlzZUltcGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG5ldyBwcm9taXNlSW1wbDxzdHJpbmc+KFxuICAgICAgICBmdW5jdGlvbiAocmVzb2x2ZTogRnVuY3Rpb24sIHJlamVjdDogRnVuY3Rpb24pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVGbiA9IGhhbmRsZUNhY2hlKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGVtcGxhdGVGbihkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEV0YUVycihcbiAgICAgICAgXCJQbGVhc2UgcHJvdmlkZSBhIGNhbGxiYWNrIGZ1bmN0aW9uLCB0aGlzIGVudiBkb2Vzbid0IHN1cHBvcnQgUHJvbWlzZXNcIixcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqXG4gKiBJZiBgb3B0aW9ucy5jYWNoZWAgaXMgYHRydWVgLCB0aGVuIHRoZSB0ZW1wbGF0ZSBpcyBjYWNoZWQuXG4gKlxuICogVGhpcyByZXR1cm5zIGEgdGVtcGxhdGUgZnVuY3Rpb24gYW5kIHRoZSBjb25maWcgb2JqZWN0IHdpdGggd2hpY2ggdGhhdCB0ZW1wbGF0ZSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIHJldHVybnMgYSBjb25maWcgb2JqZWN0IHdpdGggYGZpbGVuYW1lYCBzZXQuXG4gKiBPdGhlcndpc2UsIHRoZSBpbmNsdWRlZCBmaWxlIHdvdWxkIG5vdCBiZSBhYmxlIHRvIHVzZSByZWxhdGl2ZSBwYXRoc1xuICpcbiAqIEBwYXJhbSBwYXRoIHBhdGggZm9yIHRoZSBzcGVjaWZpZWQgZmlsZSAoaWYgcmVsYXRpdmUsIHNwZWNpZnkgYHZpZXdzYCBvbiBgb3B0aW9uc2ApXG4gKiBAcGFyYW0gb3B0aW9ucyBjb21waWxhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIFtFdGEgdGVtcGxhdGUgZnVuY3Rpb24sIG5ldyBjb25maWcgb2JqZWN0XVxuICovXG5cbmZ1bmN0aW9uIGluY2x1ZGVGaWxlKFxuICBwYXRoOiBzdHJpbmcsXG4gIG9wdGlvbnM6IEV0YUNvbmZpZyxcbik6IFtUZW1wbGF0ZUZ1bmN0aW9uLCBFdGFDb25maWddIHtcbiAgLy8gdGhlIGJlbG93IGNyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3QsIHVzaW5nIHRoZSBwYXJlbnQgZmlsZXBhdGggb2YgdGhlIG9sZCBvcHRpb25zIG9iamVjdCBhbmQgdGhlIHBhdGhcbiAgY29uc3QgbmV3RmlsZU9wdGlvbnMgPSBnZXRDb25maWcoXG4gICAgeyBmaWxlbmFtZTogZ2V0UGF0aChwYXRoLCBvcHRpb25zKSB9LFxuICAgIG9wdGlvbnMsXG4gICk7XG4gIC8vIFRPRE86IG1ha2Ugc3VyZSBwcm9wZXJ0aWVzIGFyZSBjdXJyZWN0bHkgY29waWVkIG92ZXJcbiAgcmV0dXJuIFtoYW5kbGVDYWNoZShuZXdGaWxlT3B0aW9ucyBhcyBFdGFDb25maWdXaXRoRmlsZW5hbWUpLCBuZXdGaWxlT3B0aW9uc107XG59XG5cbi8qKlxuICogUmVuZGVyIGEgdGVtcGxhdGUgZnJvbSBhIGZpbGVwYXRoLlxuICpcbiAqIEBwYXJhbSBmaWxlcGF0aCBQYXRoIHRvIHRlbXBsYXRlIGZpbGUuIElmIHJlbGF0aXZlLCBzcGVjaWZ5IGB2aWV3c2Agb24gdGhlIGNvbmZpZyBvYmplY3RcbiAqXG4gKiBUaGlzIGNhbiB0YWtlIHR3byBkaWZmZXJlbnQgZnVuY3Rpb24gc2lnbmF0dXJlczpcbiAqXG4gKiAtIGByZW5kZXJGaWxlKGZpbGVuYW1lLCBkYXRhLCBbY2JdKWBcbiAqIC0gYHJlbmRlckZpbGUoZmlsZW5hbWUsIGRhdGEsIFtjb25maWddLCBbY2JdKWBcbiAqXG4gKiBOb3RlIHRoYXQgcmVuZGVyRmlsZSBkb2VzIG5vdCBpbW1lZGlhdGVseSByZXR1cm4gdGhlIHJlbmRlcmVkIHJlc3VsdC4gSWYgeW91IHBhc3MgaW4gYSBjYWxsYmFjayBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgKGVyciwgcmVzKWAuIE90aGVyd2lzZSwgYHJlbmRlckZpbGVgIHdpbGwgcmV0dXJuIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlbmRlciByZXN1bHQuXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKlxuICogYGBganNcbiAqIGV0YS5yZW5kZXJGaWxlKFwiLi90ZW1wbGF0ZS5ldGFcIiwgZGF0YSwge2NhY2hlOiB0cnVlfSwgZnVuY3Rpb24gKGVyciwgcmVuZGVyZWQpIHtcbiAqICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyKVxuICogICBjb25zb2xlLmxvZyhyZW5kZXJlZClcbiAqIH0pXG4gKlxuICogbGV0IHJlbmRlcmVkID0gYXdhaXQgZXRhLnJlbmRlckZpbGUoXCIuL3RlbXBsYXRlLmV0YVwiLCBkYXRhLCB7Y2FjaGU6IHRydWV9KVxuICpcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHJlbmRlckZpbGUoXG4gIGZpbGVuYW1lOiBzdHJpbmcsXG4gIGRhdGE6IERhdGFPYmosXG4gIGNvbmZpZz86IFBhcnRpYWxDb25maWcsXG4pOiBQcm9taXNlPHN0cmluZz47XG5cbmZ1bmN0aW9uIHJlbmRlckZpbGUoXG4gIGZpbGVuYW1lOiBzdHJpbmcsXG4gIGRhdGE6IERhdGFPYmosXG4gIGNvbmZpZzogUGFydGlhbENvbmZpZyxcbiAgY2I6IENhbGxiYWNrRm4sXG4pOiB2b2lkO1xuXG5mdW5jdGlvbiByZW5kZXJGaWxlKFxuICBmaWxlbmFtZTogc3RyaW5nLFxuICBkYXRhOiBEYXRhT2JqLFxuICBjb25maWc/OiBQYXJ0aWFsQ29uZmlnLFxuICBjYj86IENhbGxiYWNrRm4sXG4pOiBQcm9taXNlPHN0cmluZz4gfCB2b2lkO1xuXG5mdW5jdGlvbiByZW5kZXJGaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGRhdGE6IERhdGFPYmosIGNiOiBDYWxsYmFja0ZuKTogdm9pZDtcblxuZnVuY3Rpb24gcmVuZGVyRmlsZShcbiAgZmlsZW5hbWU6IHN0cmluZyxcbiAgZGF0YTogRGF0YU9iaixcbiAgY29uZmlnPzogUGFydGlhbENvbmZpZyxcbiAgY2I/OiBDYWxsYmFja0ZuLFxuKTogUHJvbWlzZTxzdHJpbmc+IHwgdm9pZCB7XG4gIC8qXG4gIEhlcmUgd2UgaGF2ZSBzb21lIGZ1bmN0aW9uIG92ZXJsb2FkaW5nLlxuICBFc3NlbnRpYWxseSwgdGhlIGZpcnN0IDIgYXJndW1lbnRzIHRvIHJlbmRlckZpbGUgc2hvdWxkIGFsd2F5cyBiZSB0aGUgZmlsZW5hbWUgYW5kIGRhdGFcbiAgRXhwcmVzcyB3aWxsIGNhbGwgcmVuZGVyRmlsZSB3aXRoIChmaWxlbmFtZSwgZGF0YSwgY2IpXG4gIFdlIGFsc28gd2FudCB0byBtYWtlIChmaWxlbmFtZSwgZGF0YSwgb3B0aW9ucywgY2IpIGF2YWlsYWJsZVxuICAqL1xuXG4gIGxldCByZW5kZXJDb25maWc6IEV0YUNvbmZpZ1dpdGhGaWxlbmFtZTtcbiAgbGV0IGNhbGxiYWNrOiBDYWxsYmFja0ZuIHwgdW5kZWZpbmVkO1xuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyBGaXJzdCwgYXNzaWduIG91ciBjYWxsYmFjayBmdW5jdGlvbiB0byBgY2FsbGJhY2tgXG4gIC8vIFdlIGNhbiBsZWF2ZSBpdCB1bmRlZmluZWQgaWYgbmVpdGhlciBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbjtcbiAgLy8gQ2FsbGJhY2tzIGFyZSBvcHRpb25hbFxuICBpZiAodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBUaGUgNHRoIGFyZ3VtZW50IGlzIHRoZSBjYWxsYmFja1xuICAgIGNhbGxiYWNrID0gY2I7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gVGhlIDNyZCBhcmcgaXMgdGhlIGNhbGxiYWNrXG4gICAgY2FsbGJhY2sgPSBjb25maWc7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBhIGNvbmZpZyBvYmplY3QgcGFzc2VkIGluIGV4cGxpY2l0bHksIHVzZSBpdFxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJvYmplY3RcIikge1xuICAgIHJlbmRlckNvbmZpZyA9IGdldENvbmZpZyhcbiAgICAgIChjb25maWcgYXMgUGFydGlhbENvbmZpZykgfHwge30sXG4gICAgKSBhcyBFdGFDb25maWdXaXRoRmlsZW5hbWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBnZXQgdGhlIGRlZmF1bHQgY29uZmlnXG4gICAgcmVuZGVyQ29uZmlnID0gZ2V0Q29uZmlnKHt9KSBhcyBFdGFDb25maWdXaXRoRmlsZW5hbWU7XG4gIH1cblxuICAvLyBTZXQgdGhlIGZpbGVuYW1lIG9wdGlvbiBvbiB0aGUgdGVtcGxhdGVcbiAgLy8gVGhpcyB3aWxsIGZpcnN0IHRyeSB0byByZXNvbHZlIHRoZSBmaWxlIHBhdGggKHNlZSBnZXRQYXRoIGZvciBkZXRhaWxzKVxuICByZW5kZXJDb25maWcuZmlsZW5hbWUgPSBnZXRQYXRoKGZpbGVuYW1lLCByZW5kZXJDb25maWcpO1xuXG4gIHJldHVybiB0cnlIYW5kbGVDYWNoZShkYXRhLCByZW5kZXJDb25maWcsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSB0ZW1wbGF0ZSBmcm9tIGEgZmlsZXBhdGggYXN5bmNocm9ub3VzbHkuXG4gKlxuICogQHBhcmFtIGZpbGVwYXRoIFBhdGggdG8gdGVtcGxhdGUgZmlsZS4gSWYgcmVsYXRpdmUsIHNwZWNpZnkgYHZpZXdzYCBvbiB0aGUgY29uZmlnIG9iamVjdFxuICpcbiAqIFRoaXMgY2FuIHRha2UgdHdvIGRpZmZlcmVudCBmdW5jdGlvbiBzaWduYXR1cmVzOlxuICpcbiAqIC0gYHJlbmRlckZpbGUoZmlsZW5hbWUsIGRhdGEsIFtjYl0pYFxuICogLSBgcmVuZGVyRmlsZShmaWxlbmFtZSwgZGF0YSwgW2NvbmZpZ10sIFtjYl0pYFxuICpcbiAqIE5vdGUgdGhhdCByZW5kZXJGaWxlIGRvZXMgbm90IGltbWVkaWF0ZWx5IHJldHVybiB0aGUgcmVuZGVyZWQgcmVzdWx0LiBJZiB5b3UgcGFzcyBpbiBhIGNhbGxiYWNrIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGAoZXJyLCByZXMpYC4gT3RoZXJ3aXNlLCBgcmVuZGVyRmlsZWAgd2lsbCByZXR1cm4gYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVuZGVyIHJlc3VsdC5cbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqXG4gKiBgYGBqc1xuICogZXRhLnJlbmRlckZpbGUoXCIuL3RlbXBsYXRlLmV0YVwiLCBkYXRhLCB7Y2FjaGU6IHRydWV9LCBmdW5jdGlvbiAoZXJyLCByZW5kZXJlZCkge1xuICogICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIpXG4gKiAgIGNvbnNvbGUubG9nKHJlbmRlcmVkKVxuICogfSlcbiAqXG4gKiBsZXQgcmVuZGVyZWQgPSBhd2FpdCBldGEucmVuZGVyRmlsZShcIi4vdGVtcGxhdGUuZXRhXCIsIGRhdGEsIHtjYWNoZTogdHJ1ZX0pXG4gKlxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyRmlsZUFzeW5jKFxuICBmaWxlbmFtZTogc3RyaW5nLFxuICBkYXRhOiBEYXRhT2JqLFxuICBjb25maWc/OiBQYXJ0aWFsQ29uZmlnLFxuKTogUHJvbWlzZTxzdHJpbmc+O1xuXG5mdW5jdGlvbiByZW5kZXJGaWxlQXN5bmMoXG4gIGZpbGVuYW1lOiBzdHJpbmcsXG4gIGRhdGE6IERhdGFPYmosXG4gIGNvbmZpZzogUGFydGlhbENvbmZpZyxcbiAgY2I6IENhbGxiYWNrRm4sXG4pOiB2b2lkO1xuXG5mdW5jdGlvbiByZW5kZXJGaWxlQXN5bmMoXG4gIGZpbGVuYW1lOiBzdHJpbmcsXG4gIGRhdGE6IERhdGFPYmosXG4gIGNvbmZpZz86IFBhcnRpYWxDb25maWcsXG4gIGNiPzogQ2FsbGJhY2tGbixcbik6IFByb21pc2U8c3RyaW5nPiB8IHZvaWQ7XG5cbmZ1bmN0aW9uIHJlbmRlckZpbGVBc3luYyhmaWxlbmFtZTogc3RyaW5nLCBkYXRhOiBEYXRhT2JqLCBjYjogQ2FsbGJhY2tGbik6IHZvaWQ7XG5cbmZ1bmN0aW9uIHJlbmRlckZpbGVBc3luYyhcbiAgZmlsZW5hbWU6IHN0cmluZyxcbiAgZGF0YTogRGF0YU9iaixcbiAgY29uZmlnPzogUGFydGlhbENvbmZpZyxcbiAgY2I/OiBDYWxsYmFja0ZuLFxuKTogUHJvbWlzZTxzdHJpbmc+IHwgdm9pZCB7XG4gIHJldHVybiByZW5kZXJGaWxlKFxuICAgIGZpbGVuYW1lLFxuICAgIHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IHsgLi4uZGF0YSwgYXN5bmM6IHRydWUgfSA6IGRhdGEsXG4gICAgdHlwZW9mIGNvbmZpZyA9PT0gXCJvYmplY3RcIiA/IHsgLi4uY29uZmlnLCBhc3luYzogdHJ1ZSB9IDogY29uZmlnLFxuICAgIGNiLFxuICApO1xufVxuXG5leHBvcnQgeyBpbmNsdWRlRmlsZSwgcmVuZGVyRmlsZSwgcmVuZGVyRmlsZUFzeW5jIH07XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUVBQXFFO0FBRXJFLE9BQU8sTUFBTSxNQUFNLFVBQVUsQ0FBQztBQUM5QixPQUFPLE9BQU8sTUFBTSxjQUFjLENBQUM7QUFDbkMsU0FBUyxTQUFTLFFBQVEsYUFBYSxDQUFDO0FBQ3hDLFNBQVMsT0FBTyxFQUFFLFFBQVEsUUFBUSxpQkFBaUIsQ0FBQztBQUNwRCxTQUFTLFdBQVcsUUFBUSxnQkFBZ0IsQ0FBQztBQXFCN0MsYUFBYSxHQUViOzs7Ozs7Q0FNQyxHQUVELE9BQU8sU0FBUyxRQUFRLENBQ3RCLFFBQWdCLEVBQ2hCLE9BQWtDLEVBQ2xDLE9BQWlCLEVBQ0M7SUFDbEIsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxBQUFDO0lBQ2xDLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsQUFBQztJQUNwQyxJQUFJO1FBQ0YsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxBQUFDO1FBQ25ELElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDWixNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FDckIsQUFBQyxNQUFNLENBQTJCLFFBQVEsRUFDMUMsZ0JBQWdCLENBQ2pCLENBQUM7UUFDSixDQUFDO1FBQ0QsT0FBTyxnQkFBZ0IsQ0FBQztJQUMxQixFQUFFLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsTUFBTSxNQUFNLENBQ1YsZ0JBQWdCLEdBQUcsUUFBUSxHQUFHLGNBQWMsR0FB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